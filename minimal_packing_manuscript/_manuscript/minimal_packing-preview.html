<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.6.42">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


    <title>Minimal Packing Sets</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.columns{display: flex; gap: min(4vw, 1.5em);}
      div.column{flex: auto; overflow-x: auto;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      ul.task-list li input[type="checkbox"] {
        width: 0.8em;
        margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
        vertical-align: middle;
      }
    </style>

    <style>
      body.hypothesis-enabled #quarto-embed-header {
        padding-right: 36px;
      }

      #quarto-embed-header {
        height: 3em;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: solid 1px;
      }

      #quarto-embed-header h6 {
        font-size: 1.1em;
        padding-top: 0.6em;
        margin-left: 1em;
        margin-right: 1em;
        font-weight: 400;
      }

      #quarto-embed-header a.quarto-back-link,
      #quarto-embed-header a.quarto-download-embed {
        font-size: 0.8em;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-left: 1em;
        margin-right: 1em;
      }

      .quarto-back-container {
        padding-left: 0.5em;
        display: flex;
      }

      .headroom {
          will-change: transform;
          transition: transform 200ms linear;
      }

      .headroom--pinned {
          transform: translateY(0%);
      }

      .headroom--unpinned {
          transform: translateY(-100%);
      }      
    </style>

    <script>
    window.document.addEventListener("DOMContentLoaded", function () {

      var header = window.document.querySelector("#quarto-embed-header");
      const titleBannerEl = window.document.querySelector("body > #title-block-header");
      if (titleBannerEl) {
        titleBannerEl.style.paddingTop = header.clientHeight + "px";
      }
      const contentEl = window.document.getElementById('quarto-content');
      for (const child of contentEl.children) {
        child.style.paddingTop = header.clientHeight + "px";
        child.style.marginTop = "1em";
      }

      // Use the article root if the `back` call doesn't work. This isn't perfect
      // but should typically work
      window.quartoBackToArticle = () => {
        var currentUrl = window.location.href;
        window.history.back();
        setTimeout(() => {
            // if location was not changed in 100 ms, then there is no history back
            if(currentUrl === window.location.href){              
                // redirect to site root
                window.location.href = "index.html";
            }
        }, 100);
      }

      const headroom = new window.Headroom(header, {
        tolerance: 5,
        onPin: function () {
        },
        onUnpin: function () {
        },
      });
      headroom.init();
    });
    </script>

    
<script src="site_libs/manuscript-notebook/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-10daa034703793678e481cc8cee6d76f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
     <script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>   <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script> 
      <meta name="citation_title" content="Minimal Packing Sets">
<meta name="citation_author" content="Lorne Arnold">
<meta name="citation_language" content="en">
</head>

  <body class="quarto-notebook">
    <div id="quarto-embed-header" class="headroom fixed-top bg-primary">
      
      <a onclick="window.quartoBackToArticle(); return false;" class="btn btn-primary quarto-back-link" href=""><i class="bi bi-caret-left"></i> Back to Article</a>
      <h6><i class="bi bi-journal-code"></i> Article Notebook</h6>

            <a href="./minimal_packing.qmd" class="btn btn-primary quarto-download-embed" download="minimal_packing.qmd">Download Source</a>
          </div>

     <header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Minimal Packing Sets</h1>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
            <div class="quarto-title-meta-author">
          <div class="quarto-title-meta-heading">Author</div>
          <div class="quarto-title-meta-heading">Affiliation</div>
          
                <div class="quarto-title-meta-contents">
            <p class="author">Lorne Arnold <a href="mailto:arnoldl@uw.edu" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> <a href="https://orcid.org/0000-0002-6993-1642" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
          </div>
                <div class="quarto-title-meta-contents">
                    <p class="affiliation">
                        University of Washington Tacoma
                      </p>
                  </div>
                    </div>
        
        <div class="quarto-title-meta">

                      
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      </div>
    </div>



    <div class="quarto-other-links-text-target">
    </div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#mathematical-gsd" id="toc-mathematical-gsd" class="nav-link" data-scroll-target="#mathematical-gsd">Mathematical GSD</a>
  <ul class="collapse">
  <li><a href="#physical-meaning" id="toc-physical-meaning" class="nav-link" data-scroll-target="#physical-meaning">Physical meaning</a></li>
  </ul></li>
  <li><a href="#solving-for-the-minimal-packing-set" id="toc-solving-for-the-minimal-packing-set" class="nav-link" data-scroll-target="#solving-for-the-minimal-packing-set">Solving for the minimal packing set</a>
  <ul class="collapse">
  <li><a href="#uniform-particle-sizes-in-each-sieve" id="toc-uniform-particle-sizes-in-each-sieve" class="nav-link" data-scroll-target="#uniform-particle-sizes-in-each-sieve">Uniform particle sizes in each sieve</a></li>
  <li><a href="#distributed-particle-sizes-in-each-sieve" id="toc-distributed-particle-sizes-in-each-sieve" class="nav-link" data-scroll-target="#distributed-particle-sizes-in-each-sieve">Distributed particle sizes in each sieve</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">      

       <section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>Soil is fundamentally a discrete material that is, nevertheless, commonly modeled as a continuum because of the computational expense of large-scale discrete element models (DEMs). Even at lab specimen scales, DEM’s computational cost may be substantial depending on the grain sizes being modeled. Dispite these limitations, discrete models have proven useful in furthering our understanding of soil mechanics because they can spontaneously replicate realistic soil behavior as an emergent macro-scale property from a collection of particles following relatively simple interaction rules. This makes DEM an attractive tool for a multi-scale modeling approach where the constitutive behavior of a representative volume element (RVE) is characterized with a discrete model and applied at a larger scale through a continuum model. The ability of the RVE to represent a soil depends strongly on an appropriate grain size distribution match. However, in order to achieve computationally feasible models, even at lab scales, DEM simulations often use larger minimum particle sizes and more uniform distributions than their intended targets. Intuitively, discrete matches of different grain size distributions (GSDs) will require vastly different numbers of particles. But the precise relationship between GSD characteristics and the number of particles needed to match the distribution (and by extension the associated computational cost associated) is not intuitive. In this paper, we present the minimal packing set (MPS) concept. The minimal packing set is the smallest set of discrete particles needed to match a given GSD. We present a method for determining the MPS for any GSD and discuss strategies for finding the smallest MPS within a set of tolerances on the GSD. When mapped onto USCS classifications, A mapping of MPS onto USCS classification reveals a highly non-linear relationship between soil classification and computational cost of DEM modeling across several orders of magnitude.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<pre class="{Python}"><code>import gsd_lib as gl
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt</code></pre>
<p>Intro text.</p>
<p>Soil is discrete. Several frameworks use discrete approaches, but they’re difficult to manage and expensive to run.</p>
<p>But mechanics is mechanics and you can’t model something well that doesn’t replicate its underlying physical behavior. If you can replicate the underlying mechanisms, the macro-scale behavior should emerge.</p>
<p>The RVE concept is somewhat tied to grain size distribution (but not completely).</p>
<p>What is a grain-size distribution? How can it be described mathematically? How precise does a GSD need to be and how would one even measure that?</p>
<p>Which features of a GSD contribute to more or less computationally intense models?</p>
</section>
<section id="mathematical-gsd" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-gsd">Mathematical GSD</h2>
<p>To answer these questions, we need to create rigorous mathematical definitions for soil samples, sieve stacks, and a grain size distribution. Conceptually, each of these are collections of items (i.e., sets) with specific restrictions.</p>
<p>Samples are collections of particles. For the purposes of this paper, assume that particles are spherical.</p>
<p><strong>Sample S:</strong> <span class="math display">\[S = \{(x_i, q_i) : i \in I_S\}\]</span> where:</p>
<p><span class="math inline">\(X_S = \{x_i : i \in I_S\}\)</span> with <span class="math inline">\(x_1 &lt; x_2 &lt; \cdots &lt; x_{n_S}\)</span> (ordered sizes)</p>
<p><span class="math inline">\(Q = \{q_i : i \in I_S\}\)</span> (corresponding quantities)</p>
<p><span class="math inline">\(X_S \subset \mathbb{R}^+\)</span> and <span class="math inline">\(Q \subset \mathbb{Z}^+\)</span></p>
<p><strong>Grain Size Distribution G:</strong> <span class="math display">\[G = \{(x_j, v_j) : j \in I_G\}\]</span> where:</p>
<p><span class="math inline">\(X_G = \{x_j : j \in I_G\}\)</span> with <span class="math inline">\(x_1 &lt; x_2 &lt; \cdots &lt; x_{n_G}\)</span> (ordered sizes)</p>
<p><span class="math inline">\(V = \{v_j : j \in I_G\}\)</span> (corresponding volumes)</p>
<p><span class="math inline">\(X_G \subset \mathbb{R}^+\)</span> and <span class="math inline">\(V \subset \mathbb{R}^+\)</span></p>
<p><strong>Completeness Condition for G:</strong> A grain size distribution <span class="math inline">\(G\)</span> is <strong>complete</strong> if and only if: <span class="math display">\[v_{n_G} = 0\]</span></p>
<p><strong>Updated Comparison Conditions</strong> (G describing S):</p>
<p><strong>Condition 1:</strong> <span class="math inline">\(G\)</span> describes <span class="math inline">\(S\)</span> if <span class="math inline">\(\min(X_G) &lt; \min(X_S)\)</span> and <span class="math inline">\(\max(X_G) \ge \max(X_S)\)</span></p>
<p><strong>Condition 2:</strong> <span class="math inline">\(G\)</span> describes <span class="math inline">\(S\)</span> efficiently if <span class="math inline">\(\forall (x_j, x_{j+1})\)</span> consecutive in <span class="math inline">\(X_G\)</span>, <span class="math inline">\(\exists x_i \in X_S\)</span> such that <span class="math inline">\(x_j &lt; x_i \le x_{j+1}\)</span></p>
<p><strong>Condition 3:</strong> <span class="math inline">\(G\)</span> describes <span class="math inline">\(S\)</span> articulately if <span class="math inline">\(\forall (x_i, x_{i+1})\)</span> consecutive in <span class="math inline">\(X_S\)</span>, <span class="math inline">\(\exists x_j \in X_G\)</span> such that <span class="math inline">\(x_i \le x_j &lt; x_{i+1}\)</span></p>
<p><strong>Condition 4:</strong> <span class="math inline">\(G\)</span> describes <span class="math inline">\(S\)</span> accurately if for all consecutive pairs <span class="math inline">\((x_j, x_{j+1})\)</span> in <span class="math inline">\(X_G\)</span>: <span class="math display">\[v_j = \sum_{\substack{i \in I_S \\ x_j &lt; x_i \le x_{j+1}}} q_i \cdot f(x_i)\]</span></p>
<p>where <span class="math inline">\(f(x)\)</span> is a scaling function that converts size to volume.</p>
<section id="physical-meaning" class="level3">
<h3 class="anchored" data-anchor-id="physical-meaning">Physical meaning</h3>
<p>Practically, we use masses, rather than volumes in grain size distributions. Assuming the particles are of the same density, we can add a mass component to <span class="math inline">\(G\)</span> by multiplying <span class="math inline">\(V\)</span> by the density, <span class="math inline">\(\rho\)</span>.</p>
<p>For a complete grain size distribution, we can also define a percentage (most often by mass), <span class="math inline">\(\Lambda\)</span>, for each size.</p>
<p>The conditions above are focused on how <span class="math inline">\(G\)</span> describes <span class="math inline">\(S\)</span>, but in reality, we develop grain size distributions from direct measurement of samples. The question at hand is how to generate a sample that is a good match to a known grain size distribution. We can say that <span class="math inline">\(S\)</span> matches <span class="math inline">\(G\)</span> if <span class="math inline">\(G\)</span> accurately describes <span class="math inline">\(S\)</span>.</p>
<p>Note that conditions 1, 2, and 4 are often met in laboratory testing, while condition 3 is practically impossible to meet in the lab, but easily met in discrete element simulations.</p>
</section>
</section>
<section id="solving-for-the-minimal-packing-set" class="level2">
<h2 class="anchored" data-anchor-id="solving-for-the-minimal-packing-set">Solving for the minimal packing set</h2>
<p>Let’s start with the simple case where G describes S efficiently and articulately (i.e., there is one and only one particle size retained on each sieve).</p>
<section id="uniform-particle-sizes-in-each-sieve" class="level3">
<h3 class="anchored" data-anchor-id="uniform-particle-sizes-in-each-sieve">Uniform particle sizes in each sieve</h3>
<p>Select a single particle size to represent all possible particle sizes between two sieve sizes.</p>
<section id="representative-radius" class="level4">
<h4 class="anchored" data-anchor-id="representative-radius">Representative radius</h4>
<p>Imagine a bin with a lower limit of radius, <span class="math inline">\(r_{low}\)</span> and an upper limit of radius <span class="math inline">\(r_{high}\)</span>. The distribution of the number of particle radii within the bin is given by a probability density function, <span class="math inline">\(P(r)\)</span>. Selecting a “representative” value for the bin, <span class="math inline">\(r_{rep}\)</span> would likely involve some measure of the average particle size, either by radius or volume. A representation based on volume is more appealing since the overall GSD is volume-weighted.</p>
<p>In absence of any other reason to suspect a specific distribution, a uniform distribution seems like a reasonable choice. Under a uniform distribution of radii, the mean radius would be the average of <span class="math inline">\(r_{low}\)</span> and <span class="math inline">\(r_{high}\)</span>. The radius at the mean volume of this same distribution would given by:</p>
<p><span class="math inline">\(r_{rep} = r_{low} + \frac{r_{high}-r_{low}}{p}\)</span></p>
<p>where <span class="math inline">\(p\)</span> is between <span class="math inline">\(\sqrt[3]{4}\)</span> and 2 and <span class="math inline">\(\frac{r_{low}}{r_{high}}\)</span> is between 0 and 1.</p>
<p>These come from the range of possible differences between the radius associated with the mean volume and the mean radius. If <span class="math inline">\(\frac{r_{low}}{r_{high}}\)</span> is zero, there is no lower limit to the range (i.e., <span class="math inline">\(r_{low}\)</span> is infinitely small), <span class="math inline">\(r_{mean} = r_{high}/2\)</span>, and the mean volume will be <span class="math inline">\(\frac{\pi r_{high}^3}{3}\)</span>. The radius associated with the mean volume in this case is <span class="math inline">\(\frac{r_{high}}{\sqrt[3]{4}}\)</span>. This corresponds to <span class="math inline">\(p = \sqrt[3]{4}\)</span>.</p>
<p>As <span class="math inline">\(\frac{r_{low}}{r_{high}}\)</span> <em>approaches</em> one, the difference between <span class="math inline">\(r_{low}\)</span> and <span class="math inline">\(r_{high}\)</span> becomes very small and the radius associated with the mean volume approaches the mean radius. This corresponds to <span class="math inline">\(p = 2\)</span>.</p>
<p>If <span class="math inline">\(\frac{r_{low}}{r_{high}}\)</span> is one, there is no difference between <span class="math inline">\(r_{low}\)</span> and <span class="math inline">\(r_{high}\)</span> (i.e., there is no variation in radii), and the mean volume will be <span class="math inline">\(\frac{4\pi r_{high}^3}{3}\)</span>. The radius associated with the mean volume in this case is simply <span class="math inline">\(r_{high}\)</span>. This corresponds to an indeterminate condition for <span class="math inline">\(p\)</span>.</p>
<p>Therefore, we can use the following equation to select an appropriate value of <span class="math inline">\(p\)</span> to describe a volume-based representative radius for a uniform distribution of particles between <span class="math inline">\(r_{low}\)</span> and <span class="math inline">\(r_{high}\)</span>:</p>
<p><span class="math display">\[p(\frac{r_{low}}{r_{high}}) = (2-\sqrt[3]{4})\frac{r_{low}}{r_{high}} + \sqrt[3]{4}\]</span></p>
<p>with domain <span class="math inline">\(D: [0,1]\)</span> and range <span class="math inline">\(R: [\sqrt[3]{4},2]\)</span>.</p>
<p>To confirm, create a plot of 1000 uniform distributions with <span class="math inline">\(\frac{r_{low}}{r_{high}}\)</span> between 0 and 1 with 1000 particles each and plot the resultant value of <span class="math inline">\(p\)</span> along with the analytical value.</p>
<pre class="{Python}"><code>#| label: fig-p
#| fig-cap: "Representative radius for a uniform distribution of particle sizes."

# Create a function that calculates p assuming that r_rep is the radius of a sphere with the same volume as the mean volume of the spheres in the distribution
def p_r_rep(r_low, r_high, size=1000, verbose=False):
    """
    Calculate the parameter 'p' from the radius of the mean volume of spheres with random uniformly distributed radii.
    """
    r = stats.uniform.rvs(loc=r_low, scale=r_high-r_low,size = size)
    v = 4/3*np.pi*r**3
    r_mean = np.mean(r)
    v_mean = np.mean(v)
    r_v_mean = (3*v_mean/(4*np.pi))**(1/3)
    if verbose:
        print(
        f"""For a uniform random distribution of radii from {r_low} to {r_high} with {size} samples, \nthe mean radius is {r_mean:.2f}, \nthe mean volume is {v_mean:.2f}, \nand the radius calculated from the mean volume is {r_v_mean:.2f}""")
    return (r_high-r_low)/(r_v_mean-r_low)

def p_analytical(r_low, r_high):
    return (2-4**(1/3))*(r_low/r_high) + 4**(1/3)

r_high = 10
size = 1000
r_ratio = np.linspace(0,0.999,size)
p = []
for r in r_ratio:
    p.append(p_r_rep(r_high*r, r_high))
plt.scatter(r_ratio, p, marker="o", alpha=0.5)
plt.plot([r_ratio[0],r_ratio[-1]], [p_analytical(r_high*r_ratio[0], r_high),p_analytical(r_high*r_ratio[-1], r_high)], linestyle="--", color="k")
plt.xlabel("$r_{low}/r_{high}$")
plt.ylabel("$p$")
text_plot = plt.text(0.0, 2.0, 
f"""Values for $p$ in $r_{{rep}} = r_{{low}} + \\frac{{r_{{high}}-r_{{low}}}}{{p}}$
based on uniform random distributions with {size} 
samples of radii from $r_{{low}}$ to $r_{{high}}$""")

text_plot = plt.text(0.6, 1.65, 
"""Analytical solution (dashed)
$p = (2-\\sqrt[3]{{4}}) \\frac{{r_{{low}}}}{{r_{{high}}}} + \\sqrt[3]{{4}}$
""")
plt.show()</code></pre>
</section>
<section id="particle-quantities" class="level4">
<h4 class="anchored" data-anchor-id="particle-quantities">Particle quantities</h4>
<p>Given a grain size distribution <span class="math inline">\(G\)</span> of spherical particles, the minimal packing set, <span class="math inline">\(S_{mp}\)</span> is the smallest sample (i.e., minimizing <span class="math inline">\(||S||\)</span>) that provides a sufficiently good match to <span class="math inline">\(G\)</span>. The number of sizes in <span class="math inline">\(S\)</span> will be <span class="math inline">\(n_G - 1\)</span>.</p>
<p>In order to match the <span class="math inline">\(G\)</span>, we need to fully capture the relations between the particle sizes in terms of ratios of: total mass, individual particle mass, and number of particles. These ratios can be described as:</p>
<p><span class="math display">\[\Phi = \{\frac{m_j}{m_{n_G}} : j \in I_G\} \text{; with elements } \phi_i\]</span></p>
<p><span class="math display">\[\Xi = \{\frac{x_j^3}{x_{n_G}^3} : j \in I_G\} \text{; with elements } \xi_i\]</span></p>
<p><span class="math display">\[Y = \{\frac{\phi_j}{\xi_{n_G}} : j \in I_G\} \text{; with elements } \upsilon_i\]</span></p>
<p>Because <span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\Xi\)</span>, and <span class="math inline">\(Y\)</span> are all ratios, they can be described as fractions of integers. This can be accomplished in several ways but my preferred approach is to convert all the entries in <span class="math inline">\(G\)</span> to integers by multiplying them by multiples of the inverse of their smallest elements. Once all the entries in <span class="math inline">\(G\)</span> are integers, <span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\Xi\)</span>, and <span class="math inline">\(Y\)</span> will automatically be fractions of integers. By finding the least common multiple of all the denominators of the fractions in <span class="math inline">\(Y\)</span>, we can identify the quantities needed to for</p>
<p>The quantities needed to produce <span class="math inline">\(S_{mp}\)</span> can then be found by multiplying <span class="math inline">\(Y\)</span> by the least common multiple of the denominators of the fractions in <span class="math inline">\(Y\)</span>:</p>
<p><span class="math display">\[Q = Y \cdot \text{lcm}\{d_i : \frac{n_i}{d_i} \in Y\}\]</span></p>
<p>If desired, the number can be reduced if some tolerable error is allowed. An alternative quantity set can be generated by iteratively multiplying <span class="math inline">\(Y\)</span> by every integer between 1 and <span class="math inline">\(\kappa\)</span>, finding the closest integer representation of the product, and comparing this result to the allowable tolerance.</p>
</section>
</section>
<section id="distributed-particle-sizes-in-each-sieve" class="level3">
<h3 class="anchored" data-anchor-id="distributed-particle-sizes-in-each-sieve">Distributed particle sizes in each sieve</h3>
<p>Another approach to reducing the number of particles in <span class="math inline">\(S_{mp}\)</span> is to allow an arbitrary number of sizes between the sizes in <span class="math inline">\(G\)</span>. In other words, we will find the smallest <span class="math inline">\(S\)</span> such that <span class="math inline">\(G\)</span> describes <span class="math inline">\(S\)</span> accurately and efficiently, but not articulately. This represents a more realistic model of laboratory test results. But we don’t need to identify all the sizes. In fact, for any distribution of sizes in a range, we can find a single size that can represent the same mass with the same number of particles. Because multiple sizes can exist between sizes in <span class="math inline">\(G\)</span>, we need to expand the definition of <span class="math inline">\(\Phi\)</span> to include the combination of ratios of minimum and maximum particle sizes (four possible combinations – min/min, min/max, max/min, max/max).</p>
<p>We can then follow the iterative procedure described in the previous section except that now, we multiply the expanded <span class="math inline">\(Y\)</span> and check wether the four fractions at each index <em>span</em> or are equal to an integer. When they do, these integers are <span class="math inline">\(Q\)</span>. However, now the sizes in <span class="math inline">\(S\)</span> are unknown. But we can find the ratio of the sizes as:</p>
<p><span class="math display">\[P = \sqrt[3]{\Phi}\]</span></p>
<p><em>I haven’t confirmed this, but I have the sense that the information in the last element in the expanded <span class="math inline">\(\Phi\)</span> will tell you something about the size of the largest particle.</em></p>
<p>By testing different samples with size ratios <span class="math inline">\(P\)</span> and <span class="math inline">\(x_{nG}\)</span> between its min and max value, we can find the value of <span class="math inline">\(x_{nG}\)</span> that creates a sample that is accurately and efficiently described by <span class="math inline">\(G\)</span>.</p>
<p><em>I think there might be a problem with just finding whether there’s an integer among the four elements in <span class="math inline">\(\Phi\)</span>. I think there needs to be an integer between all entries with the same denominator. If the criteria is met with the min in the </em></p>
</section>
</section>
     </main>
<!-- /main column -->  <script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>  </div> <!-- /content --> 
  
</body></html>